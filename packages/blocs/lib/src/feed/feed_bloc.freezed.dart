// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'feed_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FeedEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeedEventCopyWith<$Res> {
  factory $FeedEventCopyWith(FeedEvent value, $Res Function(FeedEvent) then) =
      _$FeedEventCopyWithImpl<$Res, FeedEvent>;
}

/// @nodoc
class _$FeedEventCopyWithImpl<$Res, $Val extends FeedEvent>
    implements $FeedEventCopyWith<$Res> {
  _$FeedEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitFeedEventImplCopyWith<$Res> {
  factory _$$InitFeedEventImplCopyWith(
          _$InitFeedEventImpl value, $Res Function(_$InitFeedEventImpl) then) =
      __$$InitFeedEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitFeedEventImplCopyWithImpl<$Res>
    extends _$FeedEventCopyWithImpl<$Res, _$InitFeedEventImpl>
    implements _$$InitFeedEventImplCopyWith<$Res> {
  __$$InitFeedEventImplCopyWithImpl(
      _$InitFeedEventImpl _value, $Res Function(_$InitFeedEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitFeedEventImpl implements InitFeedEvent {
  const _$InitFeedEventImpl();

  @override
  String toString() {
    return 'FeedEvent.preloadData()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitFeedEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) {
    return preloadData();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) {
    return preloadData?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) {
    if (preloadData != null) {
      return preloadData();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) {
    return preloadData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) {
    return preloadData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) {
    if (preloadData != null) {
      return preloadData(this);
    }
    return orElse();
  }
}

abstract class InitFeedEvent implements FeedEvent {
  const factory InitFeedEvent() = _$InitFeedEventImpl;
}

/// @nodoc
abstract class _$$GetInfoChildFeedEventImplCopyWith<$Res> {
  factory _$$GetInfoChildFeedEventImplCopyWith(
          _$GetInfoChildFeedEventImpl value,
          $Res Function(_$GetInfoChildFeedEventImpl) then) =
      __$$GetInfoChildFeedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String typeDevelopment, ChildDataModel? child});

  $ChildDataModelCopyWith<$Res>? get child;
}

/// @nodoc
class __$$GetInfoChildFeedEventImplCopyWithImpl<$Res>
    extends _$FeedEventCopyWithImpl<$Res, _$GetInfoChildFeedEventImpl>
    implements _$$GetInfoChildFeedEventImplCopyWith<$Res> {
  __$$GetInfoChildFeedEventImplCopyWithImpl(_$GetInfoChildFeedEventImpl _value,
      $Res Function(_$GetInfoChildFeedEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? typeDevelopment = null,
    Object? child = freezed,
  }) {
    return _then(_$GetInfoChildFeedEventImpl(
      typeDevelopment: null == typeDevelopment
          ? _value.typeDevelopment
          : typeDevelopment // ignore: cast_nullable_to_non_nullable
              as String,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as ChildDataModel?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChildDataModelCopyWith<$Res>? get child {
    if (_value.child == null) {
      return null;
    }

    return $ChildDataModelCopyWith<$Res>(_value.child!, (value) {
      return _then(_value.copyWith(child: value));
    });
  }
}

/// @nodoc

class _$GetInfoChildFeedEventImpl implements GetInfoChildFeedEvent {
  const _$GetInfoChildFeedEventImpl(
      {required this.typeDevelopment, this.child});

  @override
  final String typeDevelopment;
  @override
  final ChildDataModel? child;

  @override
  String toString() {
    return 'FeedEvent.getIngoChild(typeDevelopment: $typeDevelopment, child: $child)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetInfoChildFeedEventImpl &&
            (identical(other.typeDevelopment, typeDevelopment) ||
                other.typeDevelopment == typeDevelopment) &&
            (identical(other.child, child) || other.child == child));
  }

  @override
  int get hashCode => Object.hash(runtimeType, typeDevelopment, child);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetInfoChildFeedEventImplCopyWith<_$GetInfoChildFeedEventImpl>
      get copyWith => __$$GetInfoChildFeedEventImplCopyWithImpl<
          _$GetInfoChildFeedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) {
    return getIngoChild(typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) {
    return getIngoChild?.call(typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) {
    if (getIngoChild != null) {
      return getIngoChild(typeDevelopment, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) {
    return getIngoChild(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) {
    return getIngoChild?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) {
    if (getIngoChild != null) {
      return getIngoChild(this);
    }
    return orElse();
  }
}

abstract class GetInfoChildFeedEvent implements FeedEvent {
  const factory GetInfoChildFeedEvent(
      {required final String typeDevelopment,
      final ChildDataModel? child}) = _$GetInfoChildFeedEventImpl;

  String get typeDevelopment;
  ChildDataModel? get child;
  @JsonKey(ignore: true)
  _$$GetInfoChildFeedEventImplCopyWith<_$GetInfoChildFeedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SwitchChildFeedEventImplCopyWith<$Res> {
  factory _$$SwitchChildFeedEventImplCopyWith(_$SwitchChildFeedEventImpl value,
          $Res Function(_$SwitchChildFeedEventImpl) then) =
      __$$SwitchChildFeedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String typeDevelopment, ChildDataModel? child});

  $ChildDataModelCopyWith<$Res>? get child;
}

/// @nodoc
class __$$SwitchChildFeedEventImplCopyWithImpl<$Res>
    extends _$FeedEventCopyWithImpl<$Res, _$SwitchChildFeedEventImpl>
    implements _$$SwitchChildFeedEventImplCopyWith<$Res> {
  __$$SwitchChildFeedEventImplCopyWithImpl(_$SwitchChildFeedEventImpl _value,
      $Res Function(_$SwitchChildFeedEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? typeDevelopment = null,
    Object? child = freezed,
  }) {
    return _then(_$SwitchChildFeedEventImpl(
      typeDevelopment: null == typeDevelopment
          ? _value.typeDevelopment
          : typeDevelopment // ignore: cast_nullable_to_non_nullable
              as String,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as ChildDataModel?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChildDataModelCopyWith<$Res>? get child {
    if (_value.child == null) {
      return null;
    }

    return $ChildDataModelCopyWith<$Res>(_value.child!, (value) {
      return _then(_value.copyWith(child: value));
    });
  }
}

/// @nodoc

class _$SwitchChildFeedEventImpl implements SwitchChildFeedEvent {
  const _$SwitchChildFeedEventImpl({required this.typeDevelopment, this.child});

  @override
  final String typeDevelopment;
  @override
  final ChildDataModel? child;

  @override
  String toString() {
    return 'FeedEvent.switchChild(typeDevelopment: $typeDevelopment, child: $child)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwitchChildFeedEventImpl &&
            (identical(other.typeDevelopment, typeDevelopment) ||
                other.typeDevelopment == typeDevelopment) &&
            (identical(other.child, child) || other.child == child));
  }

  @override
  int get hashCode => Object.hash(runtimeType, typeDevelopment, child);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SwitchChildFeedEventImplCopyWith<_$SwitchChildFeedEventImpl>
      get copyWith =>
          __$$SwitchChildFeedEventImplCopyWithImpl<_$SwitchChildFeedEventImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) {
    return switchChild(typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) {
    return switchChild?.call(typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) {
    if (switchChild != null) {
      return switchChild(typeDevelopment, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) {
    return switchChild(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) {
    return switchChild?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) {
    if (switchChild != null) {
      return switchChild(this);
    }
    return orElse();
  }
}

abstract class SwitchChildFeedEvent implements FeedEvent {
  const factory SwitchChildFeedEvent(
      {required final String typeDevelopment,
      final ChildDataModel? child}) = _$SwitchChildFeedEventImpl;

  String get typeDevelopment;
  ChildDataModel? get child;
  @JsonKey(ignore: true)
  _$$SwitchChildFeedEventImplCopyWith<_$SwitchChildFeedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SwitchUnitsMeasurementFeedEventImplCopyWith<$Res> {
  factory _$$SwitchUnitsMeasurementFeedEventImplCopyWith(
          _$SwitchUnitsMeasurementFeedEventImpl value,
          $Res Function(_$SwitchUnitsMeasurementFeedEventImpl) then) =
      __$$SwitchUnitsMeasurementFeedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$SwitchUnitsMeasurementFeedEventImplCopyWithImpl<$Res>
    extends _$FeedEventCopyWithImpl<$Res, _$SwitchUnitsMeasurementFeedEventImpl>
    implements _$$SwitchUnitsMeasurementFeedEventImplCopyWith<$Res> {
  __$$SwitchUnitsMeasurementFeedEventImplCopyWithImpl(
      _$SwitchUnitsMeasurementFeedEventImpl _value,
      $Res Function(_$SwitchUnitsMeasurementFeedEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SwitchUnitsMeasurementFeedEventImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SwitchUnitsMeasurementFeedEventImpl
    implements SwitchUnitsMeasurementFeedEvent {
  const _$SwitchUnitsMeasurementFeedEventImpl({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'FeedEvent.switchUnitsMeasurement(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwitchUnitsMeasurementFeedEventImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SwitchUnitsMeasurementFeedEventImplCopyWith<
          _$SwitchUnitsMeasurementFeedEventImpl>
      get copyWith => __$$SwitchUnitsMeasurementFeedEventImplCopyWithImpl<
          _$SwitchUnitsMeasurementFeedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) {
    return switchUnitsMeasurement(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) {
    return switchUnitsMeasurement?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) {
    if (switchUnitsMeasurement != null) {
      return switchUnitsMeasurement(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) {
    return switchUnitsMeasurement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) {
    return switchUnitsMeasurement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) {
    if (switchUnitsMeasurement != null) {
      return switchUnitsMeasurement(this);
    }
    return orElse();
  }
}

abstract class SwitchUnitsMeasurementFeedEvent implements FeedEvent {
  const factory SwitchUnitsMeasurementFeedEvent({required final String value}) =
      _$SwitchUnitsMeasurementFeedEventImpl;

  String get value;
  @JsonKey(ignore: true)
  _$$SwitchUnitsMeasurementFeedEventImplCopyWith<
          _$SwitchUnitsMeasurementFeedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddChildInfoFeedEventImplCopyWith<$Res> {
  factory _$$AddChildInfoFeedEventImplCopyWith(
          _$AddChildInfoFeedEventImpl value,
          $Res Function(_$AddChildInfoFeedEventImpl) then) =
      __$$AddChildInfoFeedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {DateTime date,
      String notes,
      String left,
      String right,
      String typeDevelopment,
      ChildDataModel? child});

  $ChildDataModelCopyWith<$Res>? get child;
}

/// @nodoc
class __$$AddChildInfoFeedEventImplCopyWithImpl<$Res>
    extends _$FeedEventCopyWithImpl<$Res, _$AddChildInfoFeedEventImpl>
    implements _$$AddChildInfoFeedEventImplCopyWith<$Res> {
  __$$AddChildInfoFeedEventImplCopyWithImpl(_$AddChildInfoFeedEventImpl _value,
      $Res Function(_$AddChildInfoFeedEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? notes = null,
    Object? left = null,
    Object? right = null,
    Object? typeDevelopment = null,
    Object? child = freezed,
  }) {
    return _then(_$AddChildInfoFeedEventImpl(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      notes: null == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String,
      left: null == left
          ? _value.left
          : left // ignore: cast_nullable_to_non_nullable
              as String,
      right: null == right
          ? _value.right
          : right // ignore: cast_nullable_to_non_nullable
              as String,
      typeDevelopment: null == typeDevelopment
          ? _value.typeDevelopment
          : typeDevelopment // ignore: cast_nullable_to_non_nullable
              as String,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as ChildDataModel?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChildDataModelCopyWith<$Res>? get child {
    if (_value.child == null) {
      return null;
    }

    return $ChildDataModelCopyWith<$Res>(_value.child!, (value) {
      return _then(_value.copyWith(child: value));
    });
  }
}

/// @nodoc

class _$AddChildInfoFeedEventImpl implements AddChildInfoFeedEvent {
  const _$AddChildInfoFeedEventImpl(
      {required this.date,
      required this.notes,
      required this.left,
      required this.right,
      required this.typeDevelopment,
      this.child});

  @override
  final DateTime date;
  @override
  final String notes;
  @override
  final String left;
  @override
  final String right;
  @override
  final String typeDevelopment;
  @override
  final ChildDataModel? child;

  @override
  String toString() {
    return 'FeedEvent.addChildInfo(date: $date, notes: $notes, left: $left, right: $right, typeDevelopment: $typeDevelopment, child: $child)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddChildInfoFeedEventImpl &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.notes, notes) || other.notes == notes) &&
            (identical(other.left, left) || other.left == left) &&
            (identical(other.right, right) || other.right == right) &&
            (identical(other.typeDevelopment, typeDevelopment) ||
                other.typeDevelopment == typeDevelopment) &&
            (identical(other.child, child) || other.child == child));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, date, notes, left, right, typeDevelopment, child);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddChildInfoFeedEventImplCopyWith<_$AddChildInfoFeedEventImpl>
      get copyWith => __$$AddChildInfoFeedEventImplCopyWithImpl<
          _$AddChildInfoFeedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preloadData,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        getIngoChild,
    required TResult Function(String typeDevelopment, ChildDataModel? child)
        switchChild,
    required TResult Function(String value) switchUnitsMeasurement,
    required TResult Function(DateTime date, String notes, String left,
            String right, String typeDevelopment, ChildDataModel? child)
        addChildInfo,
  }) {
    return addChildInfo(date, notes, left, right, typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preloadData,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult? Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult? Function(String value)? switchUnitsMeasurement,
    TResult? Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
  }) {
    return addChildInfo?.call(date, notes, left, right, typeDevelopment, child);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preloadData,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        getIngoChild,
    TResult Function(String typeDevelopment, ChildDataModel? child)?
        switchChild,
    TResult Function(String value)? switchUnitsMeasurement,
    TResult Function(DateTime date, String notes, String left, String right,
            String typeDevelopment, ChildDataModel? child)?
        addChildInfo,
    required TResult orElse(),
  }) {
    if (addChildInfo != null) {
      return addChildInfo(date, notes, left, right, typeDevelopment, child);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedEvent value) preloadData,
    required TResult Function(GetInfoChildFeedEvent value) getIngoChild,
    required TResult Function(SwitchChildFeedEvent value) switchChild,
    required TResult Function(SwitchUnitsMeasurementFeedEvent value)
        switchUnitsMeasurement,
    required TResult Function(AddChildInfoFeedEvent value) addChildInfo,
  }) {
    return addChildInfo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedEvent value)? preloadData,
    TResult? Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult? Function(SwitchChildFeedEvent value)? switchChild,
    TResult? Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult? Function(AddChildInfoFeedEvent value)? addChildInfo,
  }) {
    return addChildInfo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedEvent value)? preloadData,
    TResult Function(GetInfoChildFeedEvent value)? getIngoChild,
    TResult Function(SwitchChildFeedEvent value)? switchChild,
    TResult Function(SwitchUnitsMeasurementFeedEvent value)?
        switchUnitsMeasurement,
    TResult Function(AddChildInfoFeedEvent value)? addChildInfo,
    required TResult orElse(),
  }) {
    if (addChildInfo != null) {
      return addChildInfo(this);
    }
    return orElse();
  }
}

abstract class AddChildInfoFeedEvent implements FeedEvent {
  const factory AddChildInfoFeedEvent(
      {required final DateTime date,
      required final String notes,
      required final String left,
      required final String right,
      required final String typeDevelopment,
      final ChildDataModel? child}) = _$AddChildInfoFeedEventImpl;

  DateTime get date;
  String get notes;
  String get left;
  String get right;
  String get typeDevelopment;
  ChildDataModel? get child;
  @JsonKey(ignore: true)
  _$$AddChildInfoFeedEventImplCopyWith<_$AddChildInfoFeedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FeedState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() load,
    required TResult Function() update,
    required TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)
        preloadDataCompleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? load,
    TResult? Function()? update,
    TResult? Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? load,
    TResult Function()? update,
    TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedState value) init,
    required TResult Function(LoadingFeedState value) load,
    required TResult Function(UpdateFeedState value) update,
    required TResult Function(PreloadDataCompletedFeedState value)
        preloadDataCompleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedState value)? init,
    TResult? Function(LoadingFeedState value)? load,
    TResult? Function(UpdateFeedState value)? update,
    TResult? Function(PreloadDataCompletedFeedState value)?
        preloadDataCompleted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedState value)? init,
    TResult Function(LoadingFeedState value)? load,
    TResult Function(UpdateFeedState value)? update,
    TResult Function(PreloadDataCompletedFeedState value)? preloadDataCompleted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeedStateCopyWith<$Res> {
  factory $FeedStateCopyWith(FeedState value, $Res Function(FeedState) then) =
      _$FeedStateCopyWithImpl<$Res, FeedState>;
}

/// @nodoc
class _$FeedStateCopyWithImpl<$Res, $Val extends FeedState>
    implements $FeedStateCopyWith<$Res> {
  _$FeedStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitFeedStateImplCopyWith<$Res> {
  factory _$$InitFeedStateImplCopyWith(
          _$InitFeedStateImpl value, $Res Function(_$InitFeedStateImpl) then) =
      __$$InitFeedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitFeedStateImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$InitFeedStateImpl>
    implements _$$InitFeedStateImplCopyWith<$Res> {
  __$$InitFeedStateImplCopyWithImpl(
      _$InitFeedStateImpl _value, $Res Function(_$InitFeedStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitFeedStateImpl implements InitFeedState {
  const _$InitFeedStateImpl();

  @override
  String toString() {
    return 'FeedState.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitFeedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() load,
    required TResult Function() update,
    required TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)
        preloadDataCompleted,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? load,
    TResult? Function()? update,
    TResult? Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? load,
    TResult Function()? update,
    TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedState value) init,
    required TResult Function(LoadingFeedState value) load,
    required TResult Function(UpdateFeedState value) update,
    required TResult Function(PreloadDataCompletedFeedState value)
        preloadDataCompleted,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedState value)? init,
    TResult? Function(LoadingFeedState value)? load,
    TResult? Function(UpdateFeedState value)? update,
    TResult? Function(PreloadDataCompletedFeedState value)?
        preloadDataCompleted,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedState value)? init,
    TResult Function(LoadingFeedState value)? load,
    TResult Function(UpdateFeedState value)? update,
    TResult Function(PreloadDataCompletedFeedState value)? preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class InitFeedState implements FeedState {
  const factory InitFeedState() = _$InitFeedStateImpl;
}

/// @nodoc
abstract class _$$LoadingFeedStateImplCopyWith<$Res> {
  factory _$$LoadingFeedStateImplCopyWith(_$LoadingFeedStateImpl value,
          $Res Function(_$LoadingFeedStateImpl) then) =
      __$$LoadingFeedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingFeedStateImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$LoadingFeedStateImpl>
    implements _$$LoadingFeedStateImplCopyWith<$Res> {
  __$$LoadingFeedStateImplCopyWithImpl(_$LoadingFeedStateImpl _value,
      $Res Function(_$LoadingFeedStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingFeedStateImpl implements LoadingFeedState {
  const _$LoadingFeedStateImpl();

  @override
  String toString() {
    return 'FeedState.load()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingFeedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() load,
    required TResult Function() update,
    required TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)
        preloadDataCompleted,
  }) {
    return load();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? load,
    TResult? Function()? update,
    TResult? Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
  }) {
    return load?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? load,
    TResult Function()? update,
    TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (load != null) {
      return load();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedState value) init,
    required TResult Function(LoadingFeedState value) load,
    required TResult Function(UpdateFeedState value) update,
    required TResult Function(PreloadDataCompletedFeedState value)
        preloadDataCompleted,
  }) {
    return load(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedState value)? init,
    TResult? Function(LoadingFeedState value)? load,
    TResult? Function(UpdateFeedState value)? update,
    TResult? Function(PreloadDataCompletedFeedState value)?
        preloadDataCompleted,
  }) {
    return load?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedState value)? init,
    TResult Function(LoadingFeedState value)? load,
    TResult Function(UpdateFeedState value)? update,
    TResult Function(PreloadDataCompletedFeedState value)? preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (load != null) {
      return load(this);
    }
    return orElse();
  }
}

abstract class LoadingFeedState implements FeedState {
  const factory LoadingFeedState() = _$LoadingFeedStateImpl;
}

/// @nodoc
abstract class _$$UpdateFeedStateImplCopyWith<$Res> {
  factory _$$UpdateFeedStateImplCopyWith(_$UpdateFeedStateImpl value,
          $Res Function(_$UpdateFeedStateImpl) then) =
      __$$UpdateFeedStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UpdateFeedStateImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$UpdateFeedStateImpl>
    implements _$$UpdateFeedStateImplCopyWith<$Res> {
  __$$UpdateFeedStateImplCopyWithImpl(
      _$UpdateFeedStateImpl _value, $Res Function(_$UpdateFeedStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UpdateFeedStateImpl implements UpdateFeedState {
  const _$UpdateFeedStateImpl();

  @override
  String toString() {
    return 'FeedState.update()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UpdateFeedStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() load,
    required TResult Function() update,
    required TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)
        preloadDataCompleted,
  }) {
    return update();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? load,
    TResult? Function()? update,
    TResult? Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
  }) {
    return update?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? load,
    TResult Function()? update,
    TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedState value) init,
    required TResult Function(LoadingFeedState value) load,
    required TResult Function(UpdateFeedState value) update,
    required TResult Function(PreloadDataCompletedFeedState value)
        preloadDataCompleted,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedState value)? init,
    TResult? Function(LoadingFeedState value)? load,
    TResult? Function(UpdateFeedState value)? update,
    TResult? Function(PreloadDataCompletedFeedState value)?
        preloadDataCompleted,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedState value)? init,
    TResult Function(LoadingFeedState value)? load,
    TResult Function(UpdateFeedState value)? update,
    TResult Function(PreloadDataCompletedFeedState value)? preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class UpdateFeedState implements FeedState {
  const factory UpdateFeedState() = _$UpdateFeedStateImpl;
}

/// @nodoc
abstract class _$$PreloadDataCompletedFeedStateImplCopyWith<$Res> {
  factory _$$PreloadDataCompletedFeedStateImplCopyWith(
          _$PreloadDataCompletedFeedStateImpl value,
          $Res Function(_$PreloadDataCompletedFeedStateImpl) then) =
      __$$PreloadDataCompletedFeedStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ChildDataModel child,
      List<FeedChestHistoryItemDataModel> listHistoryChestFeeding});

  $ChildDataModelCopyWith<$Res> get child;
}

/// @nodoc
class __$$PreloadDataCompletedFeedStateImplCopyWithImpl<$Res>
    extends _$FeedStateCopyWithImpl<$Res, _$PreloadDataCompletedFeedStateImpl>
    implements _$$PreloadDataCompletedFeedStateImplCopyWith<$Res> {
  __$$PreloadDataCompletedFeedStateImplCopyWithImpl(
      _$PreloadDataCompletedFeedStateImpl _value,
      $Res Function(_$PreloadDataCompletedFeedStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? child = null,
    Object? listHistoryChestFeeding = null,
  }) {
    return _then(_$PreloadDataCompletedFeedStateImpl(
      child: null == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as ChildDataModel,
      listHistoryChestFeeding: null == listHistoryChestFeeding
          ? _value._listHistoryChestFeeding
          : listHistoryChestFeeding // ignore: cast_nullable_to_non_nullable
              as List<FeedChestHistoryItemDataModel>,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ChildDataModelCopyWith<$Res> get child {
    return $ChildDataModelCopyWith<$Res>(_value.child, (value) {
      return _then(_value.copyWith(child: value));
    });
  }
}

/// @nodoc

class _$PreloadDataCompletedFeedStateImpl
    implements PreloadDataCompletedFeedState {
  const _$PreloadDataCompletedFeedStateImpl(
      {required this.child,
      required final List<FeedChestHistoryItemDataModel>
          listHistoryChestFeeding})
      : _listHistoryChestFeeding = listHistoryChestFeeding;

  @override
  final ChildDataModel child;
  final List<FeedChestHistoryItemDataModel> _listHistoryChestFeeding;
  @override
  List<FeedChestHistoryItemDataModel> get listHistoryChestFeeding {
    if (_listHistoryChestFeeding is EqualUnmodifiableListView)
      return _listHistoryChestFeeding;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_listHistoryChestFeeding);
  }

  @override
  String toString() {
    return 'FeedState.preloadDataCompleted(child: $child, listHistoryChestFeeding: $listHistoryChestFeeding)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PreloadDataCompletedFeedStateImpl &&
            (identical(other.child, child) || other.child == child) &&
            const DeepCollectionEquality().equals(
                other._listHistoryChestFeeding, _listHistoryChestFeeding));
  }

  @override
  int get hashCode => Object.hash(runtimeType, child,
      const DeepCollectionEquality().hash(_listHistoryChestFeeding));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PreloadDataCompletedFeedStateImplCopyWith<
          _$PreloadDataCompletedFeedStateImpl>
      get copyWith => __$$PreloadDataCompletedFeedStateImplCopyWithImpl<
          _$PreloadDataCompletedFeedStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() load,
    required TResult Function() update,
    required TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)
        preloadDataCompleted,
  }) {
    return preloadDataCompleted(child, listHistoryChestFeeding);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? load,
    TResult? Function()? update,
    TResult? Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
  }) {
    return preloadDataCompleted?.call(child, listHistoryChestFeeding);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? load,
    TResult Function()? update,
    TResult Function(ChildDataModel child,
            List<FeedChestHistoryItemDataModel> listHistoryChestFeeding)?
        preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (preloadDataCompleted != null) {
      return preloadDataCompleted(child, listHistoryChestFeeding);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitFeedState value) init,
    required TResult Function(LoadingFeedState value) load,
    required TResult Function(UpdateFeedState value) update,
    required TResult Function(PreloadDataCompletedFeedState value)
        preloadDataCompleted,
  }) {
    return preloadDataCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitFeedState value)? init,
    TResult? Function(LoadingFeedState value)? load,
    TResult? Function(UpdateFeedState value)? update,
    TResult? Function(PreloadDataCompletedFeedState value)?
        preloadDataCompleted,
  }) {
    return preloadDataCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitFeedState value)? init,
    TResult Function(LoadingFeedState value)? load,
    TResult Function(UpdateFeedState value)? update,
    TResult Function(PreloadDataCompletedFeedState value)? preloadDataCompleted,
    required TResult orElse(),
  }) {
    if (preloadDataCompleted != null) {
      return preloadDataCompleted(this);
    }
    return orElse();
  }
}

abstract class PreloadDataCompletedFeedState implements FeedState {
  const factory PreloadDataCompletedFeedState(
      {required final ChildDataModel child,
      required final List<FeedChestHistoryItemDataModel>
          listHistoryChestFeeding}) = _$PreloadDataCompletedFeedStateImpl;

  ChildDataModel get child;
  List<FeedChestHistoryItemDataModel> get listHistoryChestFeeding;
  @JsonKey(ignore: true)
  _$$PreloadDataCompletedFeedStateImplCopyWith<
          _$PreloadDataCompletedFeedStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
